# MathMod Overview

MathMod is a powerful yet easy to use mathematical software that allows you to perform complex 3D and 4D surface modeling and rendering.
MathMod support implicit and parametric surfaces and offers a very large database of model samples that can be generated with it. Apart from visualizing the actual shape, you are also free to edit the scripts and equations in order to understand how each parameter influences and reshapes the model.

MathMod allows you to play and learn, as well as generate objects which you can then export to OBJ format and use with a multitude of 3D mesh modeling program such as Blender, Meshlab...

Moreover, MathMod can also be used to generate animations that showcase how the model morphs as it is given new parameters to work with.

# Supported types of mathematical equations
## 1. Parametric equation
### Introduction
In mathematics, a parametric equation defines a group of quantities as functions of one or more independent variables called parameters. Parametric equations are commonly used to express the coordinates of the points that make up a geometric object such as a curve or surface, in which case the equations are collectively called a parametric representation or parameterization (alternatively spelled as parametrisation) of the object.

For example, the equations : x = cos(t) y = sin(t)

form a parametric representation of the unit circle, where t is the parameter: A point (x, y) is on the unit circle if and only if there is a value of t such that these two equations generate that point.

In addition to curves and surfaces, parametric equations can describe manifolds and algebraic varieties of higher dimension, with the number of parameters being equal to the dimension of the manifold or variety, and the number of equations being equal to the dimension of the space in which the manifold or variety is considered.

### Parametric surface

A parametric surface is the image of an open subset of the Euclidean plane (typically R^2) by a continuous function, in a topological space, generally a Euclidean space of dimension at least three. Usually the function is supposed to be continuously differentiable.

## 2. Implicit function
### introduction
In mathematics, an implicit equation is a relation of the form R ( x 1 , … , x n ) = 0 , where R is a function of several variables (often a polynomial).

For example, the implicit equation of the unit circle is x 2 + y 2 − 1 = 0 .
### Implicit surface
An implicit surface in a Euclidean space (or, more generally, in an affine space) of dimension 3 is the set of the common zeros of a differentiable function of three variables

    f ( x , y , z ) = 0.

## 3. Procedural texture
In computer graphics, a procedural texture is a texture created using a mathematical description (i.e. an algorithm) rather than directly stored data. The advantage of this approach is low storage cost, unlimited texture resolution and easy texture mapping. These kinds of textures are often used to model surface or volumetric representations of natural elements such as wood, marble, granite, metal, stone, and others.

### Solid texturing
Solid texturing is a process where the texture generating function is evaluated over R^3 at each visible surface point of the model so the resulting material properties (like color, shininess or normal) depends only on their 3D position, not their parametrized 2D surface position like in traditional 2D texture mapping. Consequently, solid textures are unaffected by distortions of the surface parameter space, such as you might see near the poles of a sphere.
Initially these functions were based on simple combination of procedural noise functions like Simplex noise or Perlin noise.

### Cellular texturing
Cellular texturing differs from the majority of other procedural texture generating techniques as it does not depend on noise functions as its basis, although it is often used to complement the technique. Cellular textures are based on feature points which are scattered over a three-dimensional space. These points are then used to split up the space into small, randomly tiled regions called cells. These cells often look like "lizard scales", "pebbles", or "flagstones". Even though these regions are discrete, the cellular basis function itself is continuous and can be evaluated anywhere in space. Worley noise is a common type of cellular texture

### Perlin noise
Perlin noise is a type of gradient noise developed by Ken Perlin in 1983 as a result of his frustration with the "machine-like" look of computer-generated imagery (CGI) at the time. He formally described his findings in a SIGGRAPH paper in 1985 called An image Synthesizer.

### Worley noise
Worley noise is a noise function introduced by Steven Worley in 1996. In computer graphics it is used to create procedural textures,[1] that is textures that are created automatically in arbitrary precision and do not have to be drawn by hand. Worley noise comes close to simulating textures of stone, water, or cell noise.


ref: https://en.wikipedia.org/wiki/Procedural_texture#Solid_texturing


# MathMod scripts

## 1. Scripts file format
MathMod scripts are in JSON file format.
A JSON file is a file that stores simple data structures and objects in JavaScript Object Notation (JSON) format, which is a standard data interchange format. It is primarily used for transmitting data between a web application and a server.

JSON objects are written in key/value pairs. Keys must be strings, and values must be a valid JSON data type (string, number, object, array, boolean or null). Keys and values are separated by a colon. Each key/value pair is separated by a comma.

## 2. Supported mathematical objects:
There are four major type of mathematical objects supported by MathMod:
1.  **"Iso3D"**    : Isosurfaces
2.  **"Param3D"**  : 3D parametric surfaces
3.  **"Param4D"**  : 4D parametric surfaces
4.  **"ParIso"**   : Isosurfaces + 3D parametric surfaces ("Iso3D" + "Param3D")

## 3. Mandatory Keys according to the mathematical object type:
1. ### Mandatory Keys for "Iso3D", "Param3D" and "Param4D":

 * **"Name"** : The script name is required and must be unique for each script. It's used to identify a script when stored in a collection file.
 * **"Component"**: A mathematical object can a composition of more than one mathematical equation.
 To help identify each component in a set of mathematically defined surfaces,  you must give each component a name (not necessarily unique though).

2. ### Mandatory Keys for "Iso3D":
 * **"Fxyz"**: implicit equations
 * **"Xmax", "Xmin", "Ymax", "Ymin", "Zmax", "Zmin"** : Isosurface definition domain limits.

3. ### Mandatory Keys for "Param3D" and "Param4D":
 * **"Fx", "Fy" , "Fz"**: Parametric equations in the 3D space. **"Fw"** is required as the fourth dimension ("Param4D")
 * **"Umax", "Umin", "Vmax", "Vmin"**: Domain limits for u and v parameters.

## 4. Optional Keys:

* **"Funct"**: User defined functions.
Example:
>     "Funct": ["Si=sinx", "Co=cos(y), "SC=Si(x,y,z,t)*Co(x,y,z,t)"]

* **"Const"**: User defined Constantes.
Example:
>     "Const": ["N=5", "P=pi/2", "E=N*P"]

* **"Cnd"**: An implicit equation (according to x,y and z) to characterize a region in 3D space. The number of equations must be the same as the number of components.
Example for an object including three components:
>     "Cnd":["x>0", "", "y<0"]

* **"Grid"**: User defined grid values. The number of grid values is related to the number of components:
Isosurfaces require one grid value for each component (ie: the same grid value for parameters "x", "y" and "z") but parametric surfaces require two (ie one for "u" and one for "v")
Example for a parametric surface with one component:
>     "Grid":["100", "150"]

* **"Description"**: Gives some information about the script author, date of release...
Example:
>     "Description": ["Blobby Torus by Abderrahman Taha 07/10/2019"]
* ** _Any added new key will be simply ignored by MathMod unless it violates some syntax format rules for Objects in JSON_**

## 5. Texture and Pigment:
* **"Noise"**: Noise function. MathMod supports two noise functions, Worley (NoiseW) and Perlin (NoiseP).
>         "Noise": "NoiseP(x,y,z,Octaves,Lacunarity,Gain)"
>         octaves: the number of levels of detail you want you perlin noise to have.
>         lacunarity: number that determines how much detail is added or removed at each octave (adjusts frequency).
>         Gain: number that determines how much each octave contributes to the overall shape (adjusts amplitude).

>         "Noise": "NoiseW(x,y,z,(1),(2),(0))"
* **"Texture"**: The texture generating function is evaluated over R^3 at each visible surface point of the model.

Example:
>     "Texture": {
>         "Name": "Lines",
>         "Noise": "NoiseW(x,y,z,(1),(2),(0))",
>         "Colors": [
>             "R=cos((x*x+y*y+z*z)*pi)",
>             "G=cos((x*x+y*y+z*z)*pi)*cos(x*pi)",
>             "B=sin(y*pi)*cos(x*pi)",
>             "T=1"
>         ]
>     }

* **"Pigment"**: Pigment definition.
Most of the color patterns do not use abrupt color changes of just two or three colors like those in the brick, checker or hexagon patterns. They instead use smooth transitions of many colors that gradually change from one point to the next. The colors are defined in a pigment modifier that describes how the pattern blends from one color to the next.
Each of the various pattern types available is in fact a mathematical function that takes any x, y, z location and turns it into a number. That number is used to specify what mix of colors to use from the color map: The pattern function gradient is evaluated and compared to the value of the first element in the "Vrgba" list (ie: "V=..."): if Gradient(x,y,z) is less than V[i] , color(x,y,z) = (R[i], G[i], B[i], A[i]) where "i" is the index of the "Color" object.
In the example bellow, the gradient function is:  Gradient(x,y,z)=3*atan((x*x*y*z)*pi)*cos(y*y*z*pi);
and V={0/10, 3/10, 5/10}

>     "Pigment": {
>         "Gradient": "3*atan((x*x*y*z)*pi)*cos(y*y*z*pi)",
>         "Name": "Pigment",
>         "Noise": "NoiseW(x,y,z,(1),(2),(0))",
>         "Colors": [
>             {
>                 "Color": {
>                     "Name": "Gold",
>                     "Vrgba": [
>                         "V=0/10",  //i=0
>                         "R=9/10",
>                         "G=7/10",
>                         "B=1/10",
>                         "A=1"
>                     ]
>                 }
>             },
>             {
>                 "Color": {
>                     "Name": "Red",
>                     "Vrgba": [
>                         "V=3/10",  //i=1
>                         "R=1",
>                         "G=1/10",
>                         "B=31/100",
>                         "A=1"
>                     ]
>                 }
>             },
>             {
>                 "Color": {
>                     "Name": "Green",
>                     "Vrgba": [
>                         "V=5/10",  //i=2
>                         "R=1/10",
>                         "G=7/10",
>                         "B=1/10",
>                         "A=1"
>                     ]
>                 }
>             }
>         ]
>     }

Ref: https://www.povray.org/documentation/view/3.6.1/335/

# Script example:
 * A Pariso Object made out of two Isosurfaces and one parametric surface:
>     {
>         "Name": "Pariso_01",
>         "ParIso": [
>     {
>         "Iso3D": {
>             "Description": ["Schwarz-Plan Intersection by Abderrahman Taha 20/02/2020"],
>             "Cnd": ["(x-y-(3/2)*z<0)",""],
>             "Const": ["A=4","B=6"],
>             "Component": ["Schwarz","Plan"],
>             "Grid": ["30","20"],
>             "Fxyz": ["cos(x-4*sin(t*pi))+cos(y)+cos(z)","x-y-(3/2)*z-(1/100)"],
>             "Name": ["Models_Intersection"],
>             "Xmax": ["A+4*sin(t*pi)","B"],
>             "Xmin": ["-A+4*sin(t*pi)","-B"],
>             "Ymax": ["A","B"],
>             "Ymin": ["-A","-B"],
>             "Zmax": ["A","B"],
>             "Zmin": ["-A","-B"]
>         }
>     }
>     ,
>     {
>       "Param3D": {
>         "Name": ["Sinus"],
>         "Component": ["Sinus"],
>         "Fx": ["u"],
>         "Fy": ["v"],
>         "Fz": ["-sin(pi*((u)^2+(v)^2))/3"],
>         "Umin": ["-1"],
>         "Umax": ["1"],
>         "Vmin": ["-1"],
>         "Vmax": ["1"]
>       }
>     }
>        ]
>     }



<center><h1>Supported operators and mathematical functions: </h1></center>


<p>The function string understood by MathMod is very similar (but not
completely identical in all aspects) to mathematical expressions in the
C/C++ languages.
Arithmetic float expressions can be created from float literals, variables
or functions using the following operators in this order of precedence:

<p>MathMod supports these operators:

<p><table border=2>
 <tr>
  <td><code>()</code></td>
  <td>expressions in parentheses first</td>
 </tr><tr>
  <td><code>A unit</code></td>
  <td>a unit multiplier (if one has been added)</td>
 </tr><tr>
  <td><code>A^B</code></td>
  <td>exponentiation (A raised to the power B)</td>
 </tr><tr>
  <td><code>-A</code></td>
  <td>unary minus</td>
 </tr><tr>
  <td><code>!A</code></td>
  <td>unary logical not (result is 1 if <code>int(A)</code> is 0, else 0)</td>
 </tr><tr>
  <td><code>A*B  A/B  A%B</code></td>
  <td>multiplication, division and modulo</td>
 </tr><tr>
  <td><code>A+B  A-B</code></td>
  <td>addition and subtraction</td>
 </tr><tr>
  <td><code>A=B  A&lt;B  A&lt;=B<br>A!=B  A&gt;B  A&gt;=B</code></td>
  <td>comparison between A and B (result is either 0 or 1)</td>
 </tr><tr>
  <td><code>A&amp;B</code></td>
  <td>result is 1 if <code>int(A)</code> and <code>int(B)</code> differ from
      0, else 0.<br>
      Note: Regardless of the values, both operands are always
      evaluated. However, if the expression is optimized, it may
      be changed such that only one of the operands is evaluated,
      according to standard shortcut logical operation semantics.</td>
 </tr><tr>
  <td><code>A|B</code></td>
  <td>result is 1 if <code>int(A)</code> or <code>int(B)</code> differ from 0,
      else 0.<br>
      Note: Regardless of the values, both operands are always
      evaluated. However, if the expression is optimized, it may
      be changed such that only one of the operands is evaluated,
      according to standard shortcut logical operation semantics.</td>
 </tr>
</table>


<p>MathMod supports these functions:

<p><table border=2>
<tr>
 <td><code>abs(A)</code></td>
 <td>Absolute value (magnitude) of A.
     With real numbers, if A is negative, returns -A otherwise returns A.
     With complex numbers, equivalent to <code>hypot(real(x),imag(x))</code>.</td>
</tr><tr>
  <td><code>acos(A)</code></td>
  <td>Arc-cosine of A. Returns the angle, measured in radians, whose cosine is A.</td>
</tr><tr>
  <td><code>acosh(A)</code></td>
  <td>Same as acos() but for hyperbolic cosine.</td>
</tr><tr>
  <td><code>arg(A)</code></td>
  <td>Phase angle of complex number A. Equivalent to <code>atan2(imag(x),real(x))</code>.</td>
</tr><tr>
  <td><code>asin(A)</code></td>
  <td>Arc-sine of A. Returns the angle, measured in radians, whose sine is A.</td>
</tr><tr>
  <td><code>asinh(A)</code></td>
  <td>Same as asin() but for hyperbolic sine.</td>
</tr><tr>
  <td><code>atan(A)</code></td>
  <td>Arc-tangent of (A). Returns the angle, measured in radians,
      whose tangent is A.</td>
</tr><tr>
  <td><code>atan2(A,B)</code></td>
  <td>Principal arc-tangent of A/B, using the signs of the
      two arguments to determine the quadrant of the result.
      Returns the solution to the two expressions
      hypot(A,B)*sin(x)=A, hypot(A,B)*cos(x)=B.
      The return value is in range -pi to pi, inclusive.</td>
</tr><tr>
  <td><code>atanh(A)</code></td>
  <td>Same as atan() but for hyperbolic tangent.</td>
</tr><tr>
  <td><code>cbrt(A)</code></td>
  <td>Cube root of A. Returns a solution to expression pow(x,3)=A.</td>
</tr><tr>
  <td><code>conj(A)</code></td>
  <td>Complex conjugate of A. Equivalent to <code>real(x) - 1i*imag(x)</code> or <code>polar(abs(x),-arg(x))</code>.</td>
</tr><tr>
  <td><code>ceil(A)</code></td>
  <td>Ceiling of A. Returns the smallest integer not smaller than A.
      Rounds up to the next higher integer. E.g. -2.9, -2.5 and -2.1 are
    rounded to -2.0, and 2.9, 2.5 and 2.1 are rounded to 3.0.</td>
</tr><tr>
  <td><code>cos(A)</code></td>
  <td>Cosine of A. Returns the cosine of the angle A, where A is
      measured in radians.</td>
</tr><tr>
  <td><code>cosh(A)</code></td>
  <td>Same as cos() but for hyperbolic cosine.</td>
</tr><tr>
  <td><code>cot(A)</code></td>
  <td>Cotangent of A. Equivalent to <code>1/tan(A)</code>.</td>
</tr><tr>
  <td><code>csc(A)</code></td>
  <td>Cosecant of A. Equivalent to <code>1/sin(A)</code>.</td>
</tr><tr>
  <td><code>eval(...)</code></td>
  <td>This a recursive call to the function to be evaluated. The
      number of parameters must be the same as the number of parameters
      taken by the function. Must be called inside <code>if()</code> to avoid
      infinite recursion.</td>
</tr><tr>
  <td><code>exp(A)</code></td>
  <td>Exponential of A. Returns the value of e raised to the power
      A where e is the base of the natural logarithm, i.e. the
      non-repeating value approximately equal to 2.71828182846.</td>
</tr><tr>
  <td><code>exp2(A)</code></td>
  <td>Base 2 exponential of A. Equivalent to <code>pow(2,A)</code>.</td>
</tr><tr>
  <td><code>floor(A)</code></td>
  <td>Floor of A. Returns the largest integer not greater than A. Rounds
      down to the next lower integer.
      E.g. -2.9, -2.5 and -2.1 are rounded to -3.0,
      and 2.9, 2.5 and 2.1 are rounded to 2.0.</td>
</tr><tr>
  <td><code>hypot(A,B)</code></td>
  <td>Euclidean distance function. Equivalent to <code>sqrt(A^2+B^2)</code>.</td>
</tr><tr>
  <td><code>if(A,B,C)</code></td>
  <td>If int(A) differs from 0, the return value of this function is B,
      else C. Only the parameter which needs to be evaluated is
      evaluated, the other parameter is skipped; this makes it safe to
      use <code>eval()</code> in them.</td>
</tr><tr>
  <td><code>imag(A)</code></td>
  <td>Return the imaginary part of complex number A. Equivalent to <code>abs(A)*sin(arg(A))</code>.</td>
</tr><tr>
  <td><code>int(A)</code></td>
  <td>Rounds A to the closest integer. Equidistant values are rounded away from
    zero. E.g. -2.9 and -2.5 are rounded to -3.0; -2.1 is rounded to -2.0,
    and 2.9 and 2.5 are rounded to 3.0; 2.1 is rounded to 2.0.</td>
</tr><tr>
  <td><code>log(A)</code></td>
  <td>Natural (base e) logarithm of A. Returns the solution to expression exp(x)=A.</td>
</tr><tr>
  <td><code>log2(A)</code></td>
  <td>Base 2 logarithm of A. Equivalent to <code>log(A)/log(2)</code>.</td>
</tr><tr>
  <td><code>log10(A)</code></td>
  <td>Base 10 logarithm of A.</td>
</tr><tr>
  <td><code>max(A,B)</code></td>
  <td>If A&gt;B, the result is A, else B.</td>
</tr><tr>
  <td><code>min(A,B)</code></td>
  <td>If A&lt;B, the result is A, else B.</td>
</tr><tr>
  <td><code>polar(A,B)</code></td>
  <td>Returns a complex number from magnitude A, phase angle B (in radians).
      Equivalent to <code>real(A)*(cos(real(B))+1i*sin(real(B)))</code>.</td>
</tr><tr>
  <td><code>pow(A,B)</code></td>
  <td>Exponentiation (A raised to the power B).</td>
</tr><tr>
  <td><code>real(A)</code></td>
  <td>Return the real part of complex number A. Equivalent to <code>abs(A)*cos(arg(A))</code>.</td>
</tr><tr>
  <td><code>sec(A)</code></td>
  <td>Secant of A. Equivalent to <code>1/cos(A)</code>.</td>
</tr><tr>
  <td><code>sin(A)</code></td>
  <td>Sine of A. Returns the sine of the angle A, where A is
      measured in radians.</td>
</tr><tr>
  <td><code>sinh(A)</code></td>
  <td>Same as sin() but for hyperbolic sine.</td>
</tr><tr>
  <td><code>sqrt(A)</code></td>
  <td>Square root of A. Returns a solution to expression pow(x,2)=A.</td>
</tr><tr>
  <td><code>tan(A)</code></td>
  <td>Tangent of A. Returns the tangent of the angle A, where A
      is measured in radians.</td>
</tr><tr>
  <td><code>tanh(A)</code></td>
  <td>Same as tan() but for hyperbolic tangent.</td>
</tr><tr>
  <td><code>trunc(A)</code></td>
  <td>Truncated value of A. Returns an integer corresponding to the value
    of A without its fractional part.
    E.g. -2.9, -2.5 and -2.1 are rounded to -2.0,
    and 2.9, 2.5 and 2.1 are rounded to 2.0.</td>
</tr>
</table>




<body>
<center>
<table>
<td width="690">

<center><h1>MathMod Features</h1></center>
<ol>
  <li>
.
  </li>
  <li>
.
</li>
</ol>


<center><h1>MathMod Usage </h1></center>

<center><h1>MathMod Overview </h1></center>

<center><h1>Supported mathematical functions: </h1></center>
<br>
<b>
<center>

<table border="0" cellspacing="1" cellpadding="2" width="50%" bgcolor="#CCCCCC">
          <tr bgcolor="#CCAAAA">
            <td width="225" style="background-color: #00CC99">Function</td>
            <td width="91" style="background-color: #00CC99">Symbol</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Sine</td>
            <td width="91">sin()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Cosine</td>
            <td width="91">cos()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Tangent</td>
            <td width="91">tan()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Arc Sine</td>
            <td width="91">asin()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Arc Cosine</td>
            <td width="91">acos()</td>
            </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Arc Tangent</td>
            <td width="91">atan()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Hyperbolic Sine</td>
            <td width="91">sinh()</td>
            </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Hyperbolic Cosine</td>
            <td width="91">cosh()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Hyperbolic Tangent</td>
            <td width="91">tanh()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Inverse Hyperbolic Sine</td>
            <td width="91">asinh()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Inverse Hyperbolic Cosine</td>
            <td width="91">acosh()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Inverse Hyperbolic Tangent</td>
            <td width="91">atanh()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Natural Logarithm</td>
            <td width="91">log()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Logarithm base 10</td>
            <td width="91">log10()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Angle</td>
            <td width="91">angle()</td>
            </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Absolute Value / Magnitude</td>
            <td width="91">abs()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Secant (equivalent to 1/cos()).</td>
            <td width="91">sec()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Cscant (equivalent to 1/sin()).</td>
            <td width="91">csc()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Cotant (equivalent to 1/tan()).</td>
            <td width="91">cot()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Modulus</td>
            <td width="91">mod()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Square Root</td>
            <td width="91">sqrt()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225"> Exponential</td>
            <td width="91">exp()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Min(A,B)</td>
            <td width="91">min(A,B)</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Max(A,B)</td>
            <td width="91">max(A,B)</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Rounds to the closest integer</td>
            <td width="91">int()</td>
          </tr>
          <tr bgcolor="#FFFFFF">
            <td width="225">Constants</td>
            <td width="91">pi</td>
          </tr>
        </table>
</center>
</b>
<br>

<center><h1>User defined functions :</h1></center>

<center><h1>Animation and Morph : </h1></center>

<center><h1>Forum : </h1></center>

<center><h1>Download : </h1></center>


</td>
</table>
</center>
</body>
