<p align="center">MathMod
An Interactive Plotting Program</p>

![](https://a.fsdn.com/con/app/proj/mathmod/screenshots/Screen%20Shot%202019-04-24%20at%205.20.26%20AM.png/max/max/1)
# MathMod
## Copyright

    Copyright (C) 2020 by Abderrahman Taha

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.


    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the
    Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

## Introduction

MathMod is a portable interactive plotting and graphing program for Windows, Linux, MacOSX and many other platforms.

MathMod allows to plot complex 3D mathematical surfaces, described by implicit or parametric equations, and offers a very large database of model samples that can be generated with it.

Apart from visualizing the actual shape, you are also free to edit the scripts and equations in order to understand how each parameter influences and reshapes the model.

Moreover, it allows to export it's mathematical models to OBJ format and generate animations that showcase how the model morphs as it is given new parameters to work with.

## Seeking-assistance

<head/><body><p align="center"><span style=" font-size:12pt;">Author: Abderrahman Taha (</span><a href="taha_ab@yahoo.fr"><span style=" font-size:12pt; text-decoration: underline; color:#60999e;">taha_ab@yahoo.fr</span></a><span style=" font-size:12pt;">)</span></p><p align="center"><span style=" font-size:12pt;">GitHub: </span><a href="https://github.com/parisolab/mathmod"><span style=" text-decoration: underline; color:#0000ff;">https://github.com/parisolab/mathmod</span></a></p><p align="center"><span style=" font-size:10pt;">Home:</span><a href="https://sourceforge.net/projects/mathmod"><span style=" text-decoration: underline; color:#0000ff;">https://sourceforge.net/projects/mathmod</span></a></p><p align="center"><span style=" font-size:10pt;">FaceBook:</span><a href="https://www.facebook.com/parisolab/"><span style=" text-decoration: underline; color:#0000ff;">https://www.facebook.com/parisolab/</span></a></p><p align="center"><span style=" font-size:10pt;">Twitter :</span><a href="https://twitter.com/parisolab"><span style=" text-decoration: underline; color:#0000ff;">https://twitter.com/parisolab</span></a></p></body>



# Introduction to Parametric/Implicit Equations and Procedural textures
## 1. Parametric equation
### Introduction
In mathematics, a parametric equation defines a group of quantities as functions of one or more independent variables called parameters. Parametric equations are commonly used to express the coordinates of the points that make up a geometric object such as a curve or surface, in which case the equations are collectively called a parametric representation or parameterization (alternatively spelled as parametrisation) of the object.

For example, the equations : x = cos(t) y = sin(t)

form a parametric representation of the unit circle, where t is the parameter: A point (x, y) is on the unit circle if and only if there is a value of t such that these two equations generate that point.

In addition to curves and surfaces, parametric equations can describe manifolds and algebraic varieties of higher dimension, with the number of parameters being equal to the dimension of the manifold or variety, and the number of equations being equal to the dimension of the space in which the manifold or variety is considered.

### Parametric surface

A parametric surface is the image of an open subset of the Euclidean plane (typically R^2) by a continuous function, in a topological space, generally a Euclidean space of dimension at least three. Usually the function is supposed to be continuously differentiable.

## 2. Implicit function
### introduction
In mathematics, an implicit equation is a relation of the form R ( x 1 , … , x n ) = 0 , where R is a function of several variables (often a polynomial).

For example, the implicit equation of the unit circle is x 2 + y 2 − 1 = 0 .
### Implicit surface
An implicit surface in a Euclidean space (or, more generally, in an affine space) of dimension 3 is the set of the common zeros of a differentiable function of three variables

    f ( x , y , z ) = 0.

## 3. Procedural texture
In computer graphics, a procedural texture is a texture created using a mathematical description (i.e. an algorithm) rather than directly stored data. The advantage of this approach is low storage cost, unlimited texture resolution and easy texture mapping. These kinds of textures are often used to model surface or volumetric representations of natural elements such as wood, marble, granite, metal, stone, and others.

### Solid texturing
Solid texturing is a process where the texture generating function is evaluated over R^3 at each visible surface point of the model so the resulting material properties (like color, shininess or normal) depends only on their 3D position, not their parametrized 2D surface position like in traditional 2D texture mapping. Consequently, solid textures are unaffected by distortions of the surface parameter space, such as you might see near the poles of a sphere.
Initially these functions were based on simple combination of procedural noise functions like Simplex noise or Perlin noise.

### Cellular texturing
Cellular texturing differs from the majority of other procedural texture generating techniques as it does not depend on noise functions as its basis, although it is often used to complement the technique. Cellular textures are based on feature points which are scattered over a three-dimensional space. These points are then used to split up the space into small, randomly tiled regions called cells. These cells often look like "lizard scales", "pebbles", or "flagstones". Even though these regions are discrete, the cellular basis function itself is continuous and can be evaluated anywhere in space. Worley noise is a common type of cellular texture



# MathMod scripts

## 1. Scripts file format
MathMod scripts are in JSON file format.
A JSON file is a file that stores simple data structures and objects in JavaScript Object Notation (JSON) format, which is a standard data interchange format. It is primarily used for transmitting data between a web application and a server.

JSON objects are written in key/value pairs. Keys must be strings, and values must be a valid JSON data type (string, number, object, array, boolean or null). Keys and values are separated by a colon. Each key/value pair is separated by a comma.

## 2. Supported mathematical objects:
There are four major type of mathematical objects supported by MathMod:
1.  **"Iso3D"**    : Isosurfaces
2.  **"Param3D"**  : 3D parametric surfaces
3.  **"Param4D"**  : 4D parametric surfaces
4.  **"ParIso"**   : Isosurfaces + 3D parametric surfaces ("Iso3D" + "Param3D")

## 3. Mandatory Keys according to the mathematical object type:
1. ### Mandatory Keys for "Iso3D", "Param3D" and "Param4D":

 * **"Name"** : The script name is required and must be unique for each script. It's used to identify a script when stored in a collection file.
 * **"Component"**: A mathematical object can a composition of more than one mathematical equation.
 To help identify each component in a set of mathematically defined surfaces,  you must give each component a name (not necessarily unique though).

2. ### Mandatory Keys for "Iso3D":
 * **"Fxyz"**: implicit equations
 * **"Xmax", "Xmin", "Ymax", "Ymin", "Zmax", "Zmin"** : Isosurface definition domain limits.

3. ### Mandatory Keys for "Param3D" and "Param4D":
 * **"Fx", "Fy" , "Fz"**: Parametric equations in the 3D space. **"Fw"** is required as the fourth dimension ("Param4D")
 * **"Umax", "Umin", "Vmax", "Vmin"**: Domain limits for u and v parameters.

## 4. Optional Keys:

<p><table border=2>
<tr>
<td><code>"Funct"</code></td>
<td>
User defined functions. Example:
<br> <code>"Funct": ["Si=sinx", "Co=cos(y), "SC=Si(x,y,z,t)*Co(x,y,z,t)"]</code>
</td>
</tr>

<tr>
<td><code>"Const"</code></td>
<td>
User defined Constantes. Example:
<br><code>"Const": ["N=5", "P=pi/2", "E=N*P"]</code>
</td>
</tr>

<tr>
<td><code>"Cnd"</code></td>
<td>
An implicit equation (according to x,y and z) to characterize a region in 3D space. The number of equations must be the same as the number of components.
Example for an object including three components:
<br><code>"Cnd":["x>0", "", "y<0"]</code>
<br> See the "Models_Intersection" script
</td>
</tr>

<tr>
<td><code>"Grid"</code></td>
<td>
User defined grid values. The number of grid values is related to the number of components.
Isosurfaces require one grid value for each component (ie: the same grid value for "x", "y" and "z") but parametric surfaces require two (ie one for "u" and one for "v")
Example for a parametric surface with one component:
<br><code>"Grid":["100", "150"]</code>
<br> See the "Models_Intersection" script
</td>
</tr>

<tr>
<td><code>"Sliders"</code></td>
<td>
Sliders are usefull for interactive modification of one or more parameter used in the script. Example:
<br><code>"Sliders": {
        "Name": ["N","R"],
        "Min": ["0","0"],
        "Max": ["50","50"],
        "Step": ["1","1"],
        "Position": ["10","16"]
    }</code>
<ul>
<li><code>"Name"</code> : The parameters names (ie. N, R).
<li><code>"Min", "Max"</code> : Minimum and maximum values for N and R.
<li><code>"Step"</code> : Value used to adjust each parameter.
<li><code>"Position"</code> : Saved values for each parameter (N, R)=(10, 16).
</ul>
<br> Function used in the "The_Dome_v1" script
</td>
</tr>

<tr>
<td><code>"Description"</code></td>
<td>
User defined functions. Example:
<br><code>"Description": ["Blobby Torus by Abderrahman Taha 07/10/2019"]</code>
</td>
</tr>

</table>

* ** _Any added new key will be simply ignored by MathMod unless it violates some syntax format rules for Objects in JSON_**

## 5. Texture and Pigment:

* **"Texture"**: The texture generating function is evaluated over R^3 at each visible surface point of the model.

Example:
>     "Texture": {
>         "Name": "Lines",
>         "Noise": "NoiseW(x,y,z,(1),(2),(0))",
>         "Colors": [
>             "R=cos((x*x+y*y+z*z)*pi)",
>             "G=cos((x*x+y*y+z*z)*pi)*cos(x*pi)",
>             "B=sin(y*pi)*cos(x*pi)",
>             "T=1"
>         ]
>     }

* **"Pigment"**: Pigment definition.
Most of the color patterns do not use abrupt color changes of just two or three colors like those in the brick, checker or hexagon patterns. They instead use smooth transitions of many colors that gradually change from one point to the next. The colors are defined in a pigment modifier that describes how the pattern blends from one color to the next.
Each of the various pattern types available is in fact a mathematical function that takes any x, y, z location and turns it into a number. That number is used to specify what mix of colors to use from the color map: The pattern function gradient is evaluated and compared to the value of the first element in the "Vrgba" list (ie: "V=..."): if Gradient(x,y,z) is less than V[i] , color(x,y,z) = (R[i], G[i], B[i], A[i]) where "i" is the index of the "Color" object.
In the example bellow, the gradient function is:  Gradient(x,y,z)=3*atan((x*x*y*z)*pi)*cos(y*y*z*pi);
and V={0/10, 3/10, 5/10}

>     "Pigment": {
>         "Gradient": "3*atan((x*x*y*z)*pi)*cos(y*y*z*pi)",
>         "Name": "Pigment",
>         "Noise": "NoiseW(x,y,z,(1),(2),(0))",
>         "Colors": [
>             {
>                 "Color": {
>                     "Name": "Gold",
>                     "Vrgba": [
>                         "V=0/10",  //i=0
>                         "R=9/10",
>                         "G=7/10",
>                         "B=1/10",
>                         "A=1"
>                     ]
>                 }
>             },
>             {
>                 "Color": {
>                     "Name": "Red",
>                     "Vrgba": [
>                         "V=3/10",  //i=1
>                         "R=1",
>                         "G=1/10",
>                         "B=31/100",
>                         "A=1"
>                     ]
>                 }
>             },
>             {
>                 "Color": {
>                     "Name": "Green",
>                     "Vrgba": [
>                         "V=5/10",  //i=2
>                         "R=1/10",
>                         "G=7/10",
>                         "B=1/10",
>                         "A=1"
>                     ]
>                 }
>             }
>         ]
>     }


# Script example:
 * A Pariso Object made out of two Isosurfaces and one parametric surface:
>     {
>         "Name": "Pariso_01",
>         "ParIso": [
>     {
>         "Iso3D": {
>             "Description": ["Schwarz-Plan Intersection by Abderrahman Taha 20/02/2020"],
>             "Cnd": ["(x-y-(3/2)*z<0)",""],
>             "Const": ["A=4","B=6"],
>             "Component": ["Schwarz","Plan"],
>             "Grid": ["30","20"],
>             "Fxyz": ["cos(x-4*sin(t*pi))+cos(y)+cos(z)","x-y-(3/2)*z-(1/100)"],
>             "Name": ["Models_Intersection"],
>             "Xmax": ["A+4*sin(t*pi)","B"],
>             "Xmin": ["-A+4*sin(t*pi)","-B"],
>             "Ymax": ["A","B"],
>             "Ymin": ["-A","-B"],
>             "Zmax": ["A","B"],
>             "Zmin": ["-A","-B"]
>         }
>     }
>     ,
>     {
>       "Param3D": {
>         "Name": ["Sinus"],
>         "Component": ["Sinus"],
>         "Fx": ["u"],
>         "Fy": ["v"],
>         "Fz": ["-sin(pi*((u)^2+(v)^2))/3"],
>         "Umin": ["-1"],
>         "Umax": ["1"],
>         "Vmin": ["-1"],
>         "Vmax": ["1"]
>       }
>     }
>     ]
>     }


<center><h1>MathMod internal functions: </h1></center>
<p><table border=2>
 <tr>
  <td><code>NoiseP</code></td>
  <td>
<p>
  <code>NoiseP(x,y,z,Octaves,Lacunarity,Gain)</code> Perlin noise is a type of gradient noise developed by Ken Perlin in 1983 as a result of his frustration with the "machine-like" look of computer-generated imagery (CGI) at the time. He formally described his findings in a SIGGRAPH paper in 1985 called An image Synthesizer.
<ul>
 <li>
   <code>Octaves</code> : the number of levels of detail you want you Perlin noise to have.
 <li>
   <code>Lacunarity</code> : number that determines how much detail is added or removed at each octave (adjusts frequency).
 <li>
   <code>Gain</code> : number that determines how much each octave contributes to the overall shape (adjusts amplitude).
</ul>
 <br> Function used in the "Perlin_Schwarz" script
</td>
 </tr>

<tr>
  <td><code>NoiseW</code></td>
  <td>
<p>
  <code>NoiseW(x,y,z,(A),(B),(C))</code> Worley noise is a noise function introduced by Steven Worley in 1996. In computer graphics it is used to create procedural textures, that is textures that are created automatically in arbitrary precision and do not have to be drawn by hand. Worley noise comes close to simulating textures of stone, water, or cell noise.
<ul>
 <li>
   <code>A, B, C</code> : Numbers between 0..2
</ul>
 <br> Function used in the "CellNoiseSchwarz" script
</td>
 </tr>

 <tr>
  <td><code>f_hex_y</code></td>
  <td>
<p>
  <code>f_hex_y(x,y,z, P0)</code>. This is function forms a lattice of infinite boxes stretching along the z-axis.
 The fatness is controlled by the threshold value. These boxes are rotated 60 degrees around centers, which are
 0.8660254 or cos(30) away from each other. This function is also useful as pigment function.
<ul>

 <li>
   <code>P0</code> : No effect (but the syntax requires at least one parameter)
</ul>
<br>
   Function used in "Wall_Pattern_..." scripts (5 scripts in total)
</td>
 </tr>


 <tr>
  <td><code>fmesh</code></td>
  <td>

<p>
  <code>f_mesh1(x,y,z, P0, P1, P2, P3, P4)</code> The overall thickness of the threads is controlled by the
 isosurface threshold, not by a parameter. If you render a mesh1 with zero threshold, the threads have zero thickness
 and are therefore invisible. Parameters P2 and P4 control the shape of the thread relative to this threshold
 parameter.
<ul>

 <li>
   <code>P0</code> : Distance between neighboring threads in the x direction
 <li>
   <code>P1</code> : Distance between neighboring threads in the z direction
 <li>
   <code>P2</code> : Relative thickness in the x and z directions
 <li>
   <code>P3</code> : Amplitude of the weaving effect. Set to zero for a flat grid
 <li>
   <code>P4</code> : Relative thickness in the y direction
</ul>
 <br> Function used in the "Straw Basket_02" script
</td>
 </tr>
  <tr>
   <td><code>fhelix1</code></td>
   <td>

<p>
  <code>f_helix1(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>
<ul>

 <li>
   <code>P0</code> : Number of helixes - e.g. 2 for a double helix
 <li>
   <code>P1</code> : Period - is related to the number of turns per unit length
 <li>
   <code>P2</code> : Minor radius (major radius &gt; minor radius)
 <li>
   <code>P3</code> : Major radius
 <li>
   <code>P4</code> : Shape parameter. If this is greater than 1 then the tube becomes fatter in the y direction
 <li>
   <code>P5</code> : cross section type, (0.0 to 1.0 = square ... rounded to circle, over 2.0 to 3.0 = rounded to diamond and concave diamond)
 <li>
   <code>P6</code> : Cross section rotation angle (degrees)
</ul>
Function use in "fhelix" and "Tori of helices" scripts
   </td>
  </tr>

  <tr>
   <td><code>fhelix2</code></td>
   <td>
<p>
  <code>f_helix2(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>. Needs a negated function
<ul>
 <li>
   <code>P0</code> : Not used
 <li>
   <code>P1</code> : Period - is related to the number of turns per unit length
 <li>
   <code>P2</code> : Minor radius (minor radius &gt; major radius)
 <li>
   <code>P3</code> : Major radius
 <li>
   <code>P4</code> : Not used
 <li>
   <code>P5</code> : cross section type, (0.0 to 1.0 = square ... rounded to circle, over 2.0 to 3.0 = rounded to diamond and concave diamond)
 <li>
   <code>P6</code> : Cross section rotation angle (degrees)
</ul>

</td>
 </tr>

 <tr>
  <td><code>p_skeletal_int</code></td>
  <td>p_skeletal_int</td>
 </tr>

</table>



<center><h1>Supported operators and mathematical functions: </h1></center>

<p>The function string understood by MathMod is very similar (but not
completely identical in all aspects) to mathematical expressions in the
C/C++ languages.
Arithmetic float expressions can be created from float literals, variables
or functions using the following operators in this order of precedence:

<p>List of mathematic operators

<p><table border=2>
 <tr>
  <td><code>()</code></td>
  <td>expressions in parentheses first</td>
 </tr><tr>
  <td><code>A unit</code></td>
  <td>a unit multiplier (if one has been added)</td>
 </tr><tr>
  <td><code>A^B</code></td>
  <td>exponentiation (A raised to the power B)</td>
 </tr><tr>
  <td><code>-A</code></td>
  <td>unary minus</td>
 </tr><tr>
  <td><code>!A</code></td>
  <td>unary logical not (result is 1 if <code>int(A)</code> is 0, else 0)</td>
 </tr><tr>
  <td><code>A*B  A/B  A%B</code></td>
  <td>multiplication, division and modulo</td>
 </tr><tr>
  <td><code>A+B  A-B</code></td>
  <td>addition and subtraction</td>
 </tr><tr>
  <td><code>A=B  A&lt;B  A&lt;=B<br>A!=B  A&gt;B  A&gt;=B</code></td>
  <td>comparison between A and B (result is either 0 or 1)</td>
 </tr><tr>
  <td><code>A&amp;B</code></td>
  <td>result is 1 if <code>int(A)</code> and <code>int(B)</code> differ from
      0, else 0.<br>
      Note: Regardless of the values, both operands are always
      evaluated. However, if the expression is optimized, it may
      be changed such that only one of the operands is evaluated,
      according to standard shortcut logical operation semantics.</td>
 </tr><tr>
  <td><code>A|B</code></td>
  <td>result is 1 if <code>int(A)</code> or <code>int(B)</code> differ from 0,
      else 0.<br>
      Note: Regardless of the values, both operands are always
      evaluated. However, if the expression is optimized, it may
      be changed such that only one of the operands is evaluated,
      according to standard shortcut logical operation semantics.</td>
 </tr>
</table>


<p>List of mathematical functions:

<p><table border=2>
<tr>
 <td><code>abs(A)</code></td>
 <td>Absolute value (magnitude) of A.
     With real numbers, if A is negative, returns -A otherwise returns A.
     With complex numbers, equivalent to <code>hypot(real(x),imag(x))</code>.</td>
</tr><tr>
  <td><code>acos(A)</code></td>
  <td>Arc-cosine of A. Returns the angle, measured in radians, whose cosine is A.</td>
</tr><tr>
  <td><code>acosh(A)</code></td>
  <td>Same as acos() but for hyperbolic cosine.</td>
</tr><tr>
  <td><code>arg(A)</code></td>
  <td>Phase angle of complex number A. Equivalent to <code>atan2(imag(x),real(x))</code>.</td>
</tr><tr>
  <td><code>asin(A)</code></td>
  <td>Arc-sine of A. Returns the angle, measured in radians, whose sine is A.</td>
</tr><tr>
  <td><code>asinh(A)</code></td>
  <td>Same as asin() but for hyperbolic sine.</td>
</tr><tr>
  <td><code>atan(A)</code></td>
  <td>Arc-tangent of (A). Returns the angle, measured in radians,
      whose tangent is A.</td>
</tr><tr>
  <td><code>atan2(A,B)</code></td>
  <td>Principal arc-tangent of A/B, using the signs of the
      two arguments to determine the quadrant of the result.
      Returns the solution to the two expressions
      hypot(A,B)*sin(x)=A, hypot(A,B)*cos(x)=B.
      The return value is in range -pi to pi, inclusive.</td>
</tr><tr>
  <td><code>atanh(A)</code></td>
  <td>Same as atan() but for hyperbolic tangent.</td>
</tr><tr>
  <td><code>cbrt(A)</code></td>
  <td>Cube root of A. Returns a solution to expression pow(x,3)=A.</td>
</tr><tr>
  <td><code>conj(A)</code></td>
  <td>Complex conjugate of A. Equivalent to <code>real(x) - 1i*imag(x)</code> or <code>polar(abs(x),-arg(x))</code>.</td>
</tr><tr>
  <td><code>ceil(A)</code></td>
  <td>Ceiling of A. Returns the smallest integer not smaller than A.
      Rounds up to the next higher integer. E.g. -2.9, -2.5 and -2.1 are
    rounded to -2.0, and 2.9, 2.5 and 2.1 are rounded to 3.0.</td>
</tr><tr>
  <td><code>cos(A)</code></td>
  <td>Cosine of A. Returns the cosine of the angle A, where A is
      measured in radians.</td>
</tr><tr>
  <td><code>cosh(A)</code></td>
  <td>Same as cos() but for hyperbolic cosine.</td>
</tr><tr>
  <td><code>cot(A)</code></td>
  <td>Cotangent of A. Equivalent to <code>1/tan(A)</code>.</td>
</tr><tr>
  <td><code>csc(A)</code></td>
  <td>Cosecant of A. Equivalent to <code>1/sin(A)</code>.</td>
</tr><tr>
  <td><code>eval(...)</code></td>
  <td>This a recursive call to the function to be evaluated. The
      number of parameters must be the same as the number of parameters
      taken by the function. Must be called inside <code>if()</code> to avoid
      infinite recursion.</td>
</tr><tr>
  <td><code>exp(A)</code></td>
  <td>Exponential of A. Returns the value of e raised to the power
      A where e is the base of the natural logarithm, i.e. the
      non-repeating value approximately equal to 2.71828182846.</td>
</tr><tr>
  <td><code>exp2(A)</code></td>
  <td>Base 2 exponential of A. Equivalent to <code>pow(2,A)</code>.</td>
</tr><tr>
  <td><code>floor(A)</code></td>
  <td>Floor of A. Returns the largest integer not greater than A. Rounds
      down to the next lower integer.
      E.g. -2.9, -2.5 and -2.1 are rounded to -3.0,
      and 2.9, 2.5 and 2.1 are rounded to 2.0.</td>
</tr><tr>
  <td><code>hypot(A,B)</code></td>
  <td>Euclidean distance function. Equivalent to <code>sqrt(A^2+B^2)</code>.</td>
</tr><tr>
  <td><code>if(A,B,C)</code></td>
  <td>If int(A) differs from 0, the return value of this function is B,
      else C. Only the parameter which needs to be evaluated is
      evaluated, the other parameter is skipped; this makes it safe to
      use <code>eval()</code> in them.</td>
</tr><tr>
  <td><code>imag(A)</code></td>
  <td>Return the imaginary part of complex number A. Equivalent to <code>abs(A)*sin(arg(A))</code>.</td>
</tr><tr>
  <td><code>int(A)</code></td>
  <td>Rounds A to the closest integer. Equidistant values are rounded away from
    zero. E.g. -2.9 and -2.5 are rounded to -3.0; -2.1 is rounded to -2.0,
    and 2.9 and 2.5 are rounded to 3.0; 2.1 is rounded to 2.0.</td>
</tr><tr>
  <td><code>log(A)</code></td>
  <td>Natural (base e) logarithm of A. Returns the solution to expression exp(x)=A.</td>
</tr><tr>
  <td><code>log2(A)</code></td>
  <td>Base 2 logarithm of A. Equivalent to <code>log(A)/log(2)</code>.</td>
</tr><tr>
  <td><code>log10(A)</code></td>
  <td>Base 10 logarithm of A.</td>
</tr><tr>
  <td><code>max(A,B)</code></td>
  <td>If A&gt;B, the result is A, else B.</td>
</tr><tr>
  <td><code>min(A,B)</code></td>
  <td>If A&lt;B, the result is A, else B.</td>
</tr><tr>
  <td><code>polar(A,B)</code></td>
  <td>Returns a complex number from magnitude A, phase angle B (in radians).
      Equivalent to <code>real(A)*(cos(real(B))+1i*sin(real(B)))</code>.</td>
</tr><tr>
  <td><code>pow(A,B)</code></td>
  <td>Exponentiation (A raised to the power B).</td>
</tr><tr>
  <td><code>real(A)</code></td>
  <td>Return the real part of complex number A. Equivalent to <code>abs(A)*cos(arg(A))</code>.</td>
</tr><tr>
  <td><code>sec(A)</code></td>
  <td>Secant of A. Equivalent to <code>1/cos(A)</code>.</td>
</tr><tr>
  <td><code>sin(A)</code></td>
  <td>Sine of A. Returns the sine of the angle A, where A is
      measured in radians.</td>
</tr><tr>
  <td><code>sinh(A)</code></td>
  <td>Same as sin() but for hyperbolic sine.</td>
</tr><tr>
  <td><code>sqrt(A)</code></td>
  <td>Square root of A. Returns a solution to expression pow(x,2)=A.</td>
</tr><tr>
  <td><code>tan(A)</code></td>
  <td>Tangent of A. Returns the tangent of the angle A, where A
      is measured in radians.</td>
</tr><tr>
  <td><code>tanh(A)</code></td>
  <td>Same as tan() but for hyperbolic tangent.</td>
</tr><tr>
  <td><code>trunc(A)</code></td>
  <td>Truncated value of A. Returns an integer corresponding to the value
    of A without its fractional part.
    E.g. -2.9, -2.5 and -2.1 are rounded to -2.0,
    and 2.9, 2.5 and 2.1 are rounded to 2.0.</td>
</tr>
</table>


Ref:
1. https://en.wikipedia.org/wiki/Procedural_texture#Solid_texturing
2. https://www.povray.org/documentation/view/3.6.1/335/
3. https://www.povray.org/documentation/view/3.6.1/448/
4. http://www.econym.demon.co.uk/isotut/substitute.htm
5. http://www.f-lohmueller.de/pov_tut/all_shapes/shapes940e.htm
6. http://warp.povusers.org/FunctionParser/fparser.html



<body>
<center>
<table>
<td width="690">
<center><h1>MathMod Features</h1></center>
<ol>
  <li> </li>
  <li> </li>
</ol>
<center><h1>MathMod Usage </h1></center>
<center><h1>MathMod Overview </h1></center>
<center><h1>Animation and Morph : </h1></center>
<center><h1>Forum : </h1></center>
<center><h1>Download : </h1></center>
</td>
</table>
</center>
</body>
